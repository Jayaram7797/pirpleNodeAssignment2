/*
*
* This is the main Helpers file
*/

// Dependencies
var crypto = require('crypto');
var config = require('./config');
var querystring = require('querystring');
var https = require('https');
var StringDecoder = require('string_decoder').StringDecoder;




// Container for the helpers Module
var helpers = {};


// Get the stripeToken using user's credentials
// Usually stripeToken is generated by the stripe's checkout box on the client side. So none of the user's credntials are passed to the server side of the application to avoid unnecessary compliances needed.
helpers.generateStripeToken = function(nameOnCard, creditCardNumber, exp_month, exp_year, cvc, callback){

	// Sanity check the input variables

	var nameOnCard = typeof(nameOnCard) == 'string' && nameOnCard.trim().length > 0 ? nameOnCard.trim() : false;

	var creditCardNumber = typeof(creditCardNumber) == 'string' && creditCardNumber.trim().length > 0 && creditCardNumber.match(/^\d+$/) ? creditCardNumber.trim() : false;

    var exp_month = typeof(exp_month) == 'number' && exp_month > 0 && exp_month < 13 ? exp_month : false;

    var exp_year = typeof(exp_year) == 'number' && exp_year >=2018 && exp_year < 2030 ? exp_year : false;
    
    var cvc = typeof(cvc) == 'number' && cvc >= 0 && cvc <= 999 ? cvc : false;

    if(nameOnCard && creditCardNumber && exp_month && exp_year && cvc){

    	// Prepare the payload 
    	var payload = {
	        'card[number]' : creditCardNumber,
	        'card[exp_month]' : exp_month,
	        'card[exp_year]' : exp_year,
	        'card[cvc]' : cvc,
	    };

	    var stringPayload = querystring.stringify(payload);

	    // configure the client for an HTTPS post
	    var requestDetails = {
	        'protocol' : 'https:',
	        'hostname' : config.stripe.hostname,
	        'method' : 'POST',
	        'path' : config.stripe.tokenPath,
	        'auth' : config.stripe.pubKey,
	        'headers' : {
	            'Content-Type' : 'application/x-www-form-urlencoded',
	            'Content-Length': Buffer.byteLength(stringPayload)
	        }
	    };
	   

	    // make the request
        var req = https.request(requestDetails,function(res){
            
            // catch the data
            var decoder = new StringDecoder('utf-8');
            var buffer = '';
            res.on('data', function(data) {
               buffer += decoder.write(data);
            });
            res.on('end', function() {
                buffer += decoder.end();

                if( this.statusCode == 200) {        
                    
                    var stripeResponse = helpers.parseJsonToObject(buffer);
                    var stripeToken = stripeResponse.id;

                    // At this point we can either create a customer token for future use by saving customer credentials in stripe or just passback the stripe token.

                    callback(false, stripeToken);                 

                } else {

                    callback(this.statusCode, 'Failed to create one time token.');
                }
            });

        });

        // Bind to the error event so it doesn't get thrown
        req.on('error',function(e){
            console.log('Error while making request to stripe',e);
        });

        // Add the payload
        req.write(stringPayload);

        // End the request
        req.end();


    }else{

    	callback('Invalid user credntials to generate stripeToken');
    }



};


helpers.chargeUsingStripe = function(amount,currency,description,source,callback){

	// Sanity check the parameters
	var amount = typeof(amount) == 'number' && amount > 0 ? amount : false;
	var currency = typeof(currency) == 'string' && currency.trim().length == 3 ? currency.trim().toLowerCase() : false;
	var description = typeof(description) == 'string' && description.trim().length > 0 ? description.trim() : false;
	var source = typeof(source) == 'string' && source.trim().length > 0 ? source.trim() : false;


	if(amount && currency && description && source){

		// Configure the request payload
	    var payload = {
	      'amount' : amount,
	      'currency' : currency,
	      'description' : description,
	      'source' : source,
	    }
	  
	    // Stringify the payload
	    var stringPayload = querystring.stringify(payload);
	  
	    // Configure the request details
	    var requestDetails = {
	      'protocol' : 'https:',
	      'hostname' : 'api.stripe.com',
	      'method' : 'POST',
	      'auth' : config.stripe.pubKey,
	      'path' : '/v1/charges',
	      'headers' : {
	        'Content-Type' : 'application/x-www-form-urlencoded',
	        'Content-Length' : Buffer.byteLength(stringPayload)
	      }
	    }
	  
	    // make the request
	    var req = https.request(requestDetails,function(res){
	        
	        // catch the data
	        var decoder = new StringDecoder('utf-8');
	        var buffer = '';
	        res.on('data', function(data) {
	           buffer += decoder.write(data);
	        });
	        res.on('end', function() {
	            buffer += decoder.end();

	            if( this.statusCode == 200 ) {
	                var chargeResponse = helpers.parseJsonToObject( buffer );
	                // j.id in this case is the stripe order id.
	                callback(false, chargeResponse.id);
	            }else {

	                callback(this.statusCode,'Failed to create charge.');
	            }
	        });

	    });

	    // Bind to the error event so it doesn't get thrown
	    req.on('error',function(e){
	        console.log('gross fail...',e);
	    });

	    // Add the payload
	    req.write(stringPayload);

	    // End the request
	    req.end();

	}else{
		callback('Invalid input parameters while charging user');
	}
	    
}



// Send the email by mailgun API
helpers.mailgun = function(email, subject, message, callback){

    // validation args:

    email = typeof(email) == 'string' && email.trim().length > 0 ? email.trim() : false;
    subject = typeof(subject) == 'string' && subject.trim().length > 0 ? subject.trim() : false;
    message = typeof(message) == 'string' && message.trim().length > 0 ? message.trim() : false;

    if( email && subject && message) {
        // make the payload for the request
        var payload = {
            from : config.mailgun.sender,
            to : email,
            subject : subject,
            text : message
        };

        var stringPayload = querystring.stringify(payload);

        // Configure the request details
        var requestDetails = {
            'protocol' : 'https:',
            'hostname' : 'api.mailgun.net',
            'method' : 'POST',
            'path' : '/v3/'+config.mailgun.domain+'/messages',
            'auth' : 'api:'+config.mailgun.apiKey,
            'headers' : {
                'Content-Type' : 'application/x-www-form-urlencoded',
                'Content-Length': Buffer.byteLength(stringPayload)
            }
        };
    
        // Instantiate the request object
        var req = https.request(requestDetails,function(res){
            // Grab the status of the sent request
            var status =  res.statusCode;

            if(status == 200 || status == 201){
              callback(false);
            } else {
              callback(status);
            }
        });

        // Bind to the error event so it doesn't get thrown
        req.on('error',function(e){
            console.log('gross fail...');
            callback(e);
        });

        // Add the payload
        req.write(stringPayload);

        // End the request
        req.end();

    } else {
        callback('Given parameters were missing or invalid');
    }

};





// Validate Password if it is of minimum 8 characters length, one Capital letter, one Samll letter, one digit and one Special Character
helpers.validatePassword = function(password){
	var isMinimum8Characters = typeof(password) == 'string' && password.trim().length >= 8 ? true : false ;
	var hasUppercase = /[A-Z]/.test(password) ? true : false;
	var hasLowercase = /[a-z]/.test(password) ? true : false;
	var hasNumber = /[0-9]/.test(password) ? true : false;
	var hasSpecial = /[ !@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password) ? true : false ;

	if(isMinimum8Characters && hasUppercase && hasLowercase && hasNumber && hasSpecial){
		return true;
	}else{
		return false;
	}
};

// Create a Random string of specified length
helpers.createRandomString = function(strLength){
	// Check the validity of the strLength
	strLength = typeof(strLength) == 'number' && strLength > 0 ? strLength : false;
	if(strLength){
		// Define all possible characters that could make random string
		var possibleCharacters = 'abcdefghijklmnopqrstuvwxyz0123456789';

		// Start the final string
		var str = '';
		for(i = 0; i < strLength; i++){
			// Get a random character from the list of possible characters
			var randomCharacter = possibleCharacters.charAt(Math.floor(Math.random() * possibleCharacters.length));
			// Append the random character generated to the random string variable
			str += randomCharacter;
		}

		// Return the final string
		return str;

	} else {
		return false;
	}
};

// Create a SHA256 hash
helpers.hash = function(str){
	if(typeof(str) == 'string' && str.length > 0){
		//config.hashingSecret
		//console.log("Hashing Secret : ", config.hashingSecret);	
		var hash = crypto.createHmac('sha256', config.hashingSecret).update(str).digest('hex');
		return hash;
	}else{
		return false;
	}
};

// Parse a JSON string to an object without throwing any errors
helpers.parseJsonToObject = function(str){
	try{
		var obj = JSON.parse(str);
		return obj;
	}catch(e){
		return {};
	}
};


// Export the module
module.exports = helpers;